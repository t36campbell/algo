{"files":[{"path":["/","Users","tyler","Desktop","projects","algo","src","array","merge_sorted.rs"],"content":"use crate::sort;\n\n/// Solution for LeetCode 88. Merge Sorted Array\npub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\n    if m < nums1.len() as i32 {\n        let binding = nums1.clone();\n        let (n1, _) = binding.split_at(m as usize);\n        nums1.clear();\n        nums1.append(&mut n1.to_vec());\n    }\n\n    if n < nums2.len() as i32 {\n        let binding = nums2.clone();\n        let (n2, _) = binding.split_at(n as usize);\n        nums2.clear();\n        nums2.append(&mut n2.to_vec());\n    }\n\n    if n <= 0 {\n        return;\n    }\n\n    if m <= 0 {\n        nums1.clear();\n        nums1.append(nums2);\n        return;\n    }\n\n    nums1.append(nums2);\n    let mut merged = sort::merge(nums1.to_vec());\n    nums1.clear();\n    nums1.append(&mut merged);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::merge;\n\n    #[test]\n    fn e1() {\n        let mut one = vec![1];\n        let mut two = vec![];\n        merge(&mut one, 1, &mut two, 0);\n\n        assert_eq!(one, vec![1]);\n        assert_eq!(one.len(), 1);\n    }\n\n    #[test]\n    fn e2() {\n        let mut one = vec![0];\n        let mut two = vec![1];\n        merge(&mut one, 0, &mut two, 1);\n\n        assert_eq!(one, vec![1]);\n        assert_eq!(one.len(), 1);\n    }\n\n    #[test]\n    fn e3() {\n        let mut one = vec![2, 0];\n        let mut two = vec![1];\n        merge(&mut one, 1, &mut two, 1);\n\n        assert_eq!(one, vec![1, 2]);\n        assert_eq!(one.len(), 2);\n    }\n\n    #[test]\n    fn e4() {\n        let mut one = vec![1, 2, 3, 4];\n        let mut two = vec![5, 6, 7, 8];\n        merge(&mut one, 4, &mut two, 4);\n\n        assert_eq!(one.len(), 8);\n        assert_eq!(one, vec![1, 2, 3, 4, 5, 6, 7, 8]);\n    }\n\n    #[test]\n    fn e5() {\n        let mut one = vec![1, 2, 3];\n        let mut two = vec![2, 5, 6];\n        merge(&mut one, 3, &mut two, 3);\n\n        assert_eq!(one.len(), 6);\n        assert_eq!(one, vec![1, 2, 2, 3, 5, 6]);\n    }\n\n    #[test]\n    fn e6() {\n        let mut one = vec![1, 3, 5, 7];\n        let mut two = vec![2, 4, 6, 8];\n        merge(&mut one, 4, &mut two, 4);\n\n        assert_eq!(one.len(), 8);\n        assert_eq!(one, vec![1, 2, 3, 4, 5, 6, 7, 8]);\n    }\n\n    #[test]\n    fn e7() {\n        let mut one = vec![1, 2, 3, 0, 0, 0];\n        let mut two = vec![2, 5, 6];\n        merge(&mut one, 3, &mut two, 3);\n\n        assert_eq!(one.len(), 6);\n        assert_eq!(one, vec![1, 2, 2, 3, 5, 6]);\n    }\n\n    #[test]\n    fn e8() {\n        let mut one = vec![4, 0, 0, 0, 0, 0];\n        let mut two = vec![1, 2, 3, 5, 6];\n        merge(&mut one, 1, &mut two, 5);\n\n        assert_eq!(one.len(), 6);\n        assert_eq!(one, vec![1, 2, 3, 4, 5, 6]);\n    }\n\n    #[test]\n    fn e9() {\n        let mut one = vec![-1, 0, 0, 3, 3, 3, 0, 0, 0];\n        let mut two = vec![1, 2, 2];\n        merge(&mut one, 6, &mut two, 3);\n\n        assert_eq!(one.len(), 9);\n        assert_eq!(one, vec![-1, 0, 0, 1, 2, 2, 3, 3, 3]);\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":14},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":7},"fn_name":null}],"covered":17,"coverable":21},{"path":["/","Users","tyler","Desktop","projects","algo","src","array","mod.rs"],"content":"pub mod merge_sorted;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","ds","array.rs"],"content":"pub trait Array<T> {\n    fn len(&self) -> usize;\n    fn get(&self, index: usize) -> Option<&T>;\n    fn set(&mut self, value: T, index: usize);\n}\n\npub struct DynamicArray<'a, T> {\n    array: &'a mut [Option<T>],\n    len: usize,\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl<'a, T> Default for DynamicArray<'a, T>\nwhere\n    T: Copy + Default,\n{\n    fn default() -> DynamicArray<'a, T> {\n        todo!()\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl<'a, T> Array<T> for DynamicArray<'a, T> {\n    // where the last item in memory is - not the actual length of the array\n    fn len(&self) -> usize {\n        todo!()\n    }\n\n    fn get(&self, index: usize) -> Option<&T> {\n        if index > self.len {\n            todo!(\"raise index out of bounds\")\n        }\n        match self.array.get(index) {\n            Some(v) => v.as_ref(),\n            None => None,\n        }\n    }\n\n    fn set(&mut self, value: T, index: usize) {\n        self.array[index] = Some(value)\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nimpl<'a, T> DynamicArray<'a, T>\nwhere\n    T: Copy + Default,\n{\n    fn init(array: Option<&'a mut [Option<T>]>) -> Self {\n        let array: &mut [Option<T>] = match array {\n            Some(a) => a,\n            None => Self::default().array,\n        };\n        Self { array, len: 0 }\n    }\n\n    fn new() -> Self {\n        Self::init(None)\n    }\n\n    fn size(&self) -> usize {\n        return self.array.len();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    #[test]\n    fn dynamic_array() {}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","ds","hash.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","ds","heap.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","ds","linked.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","ds","mod.rs"],"content":"mod array;\nmod hash;\nmod heap;\nmod linked;\nmod queue;\nmod stack;\nmod tree;\nmod trie;\n\npub use array::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","ds","queue.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","ds","stack.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","ds","tree.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","ds","trie.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","lib.rs"],"content":"pub mod array;\npub mod ds;\npub mod sort;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","tyler","Desktop","projects","algo","src","sort","bubble.rs"],"content":"/// ## Bubble Sort\n///  \n/// It repeatedly steps through the list, compares adjacent elements,\n/// and swaps them if they are in the wrong order until the entire list is sorted.\n///\n/// Time Complexity:\\\n///     - Best: *O(n)*\\\n///     - Avg: *O(n^2)*\\\n///     - Worst: *O(n^2)*\\\n///\n/// ### Example\n/// ```rust\n/// let arr = vec![1, 3, 5, 7, 2, 4, 6, 8];\n/// let merged = sort::bubble(arr);\n///\n/// assert_eq!(merged, vec![1, 2, 3, 4, 5, 6, 7, 8]);\n/// ```\npub fn bubble<T>(mut arr: Vec<T>) -> Vec<T>\nwhere\n    T: Clone + Copy + PartialOrd + std::fmt::Debug,\n{\n    let mut working = true;\n    while working {\n        working = false;\n        let mut clone = arr.clone();\n        for (i, a) in clone.iter_mut().enumerate() {\n            if arr.len() == i + 1 {\n                continue;\n            }\n\n            if a > &mut arr[i + 1] {\n                arr.swap(i, i + 1);\n                working = true\n            }\n        }\n    }\n\n    return arr;\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::sort;\n\n    #[test]\n    fn e1() {\n        let arr = vec![3, 6, 7, 1, 5, 9, 2, 8, 0, 0, 5, 8];\n        let merged = sort::bubble(arr);\n\n        assert_eq!(merged, vec![0, 0, 1, 2, 3, 5, 5, 6, 7, 8, 8, 9]);\n    }\n\n    #[test]\n    fn e2() {\n        let arr = vec![\n            \"executor\",\n            \"law\",\n            \"religion\",\n            \"eyeball\",\n            \"velocity\",\n            \"quartz\",\n            \"convection\",\n            \"wink\",\n            \"distortion\",\n            \"ecclesia\",\n            \"inhibition\",\n            \"secrecy\",\n        ];\n        let merged = sort::bubble(arr);\n\n        assert_eq!(\n            merged,\n            vec![\n                \"convection\",\n                \"distortion\",\n                \"ecclesia\",\n                \"executor\",\n                \"eyeball\",\n                \"inhibition\",\n                \"law\",\n                \"quartz\",\n                \"religion\",\n                \"secrecy\",\n                \"velocity\",\n                \"wink\"\n            ]\n        );\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":228},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":228},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":209},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","Users","tyler","Desktop","projects","algo","src","sort","merge.rs"],"content":"fn join<T>(mut left: Vec<T>, mut right: Vec<T>) -> Vec<T>\nwhere\n    T: Copy + PartialOrd + std::fmt::Debug,\n{\n    let mut merged = Vec::<T>::new();\n\n    while !left.is_empty() && !right.is_empty() {\n        let a = left.first();\n        let b = right.first();\n\n        let val = if a <= b { a.unwrap() } else { b.unwrap() };\n        merged.push(*val);\n        if a <= b {\n            left.remove(0)\n        } else {\n            right.remove(0)\n        };\n    }\n\n    merged.append(&mut left);\n    merged.append(&mut right);\n    return merged;\n}\n\n/// ## Merge Sort\n///  \n/// It recursively divides an array into smaller halves until each half contains only one element,\n/// then merges those halves together in sorted order.\n///\n/// Time Complexity:\\\n///     - Best, Worst, Avg: *O(nlogn)\\\n///\n/// ### Example\n/// ```rust\n/// let arr = vec![1, 3, 5, 7, 2, 4, 6, 8];\n/// let merged = sort::merge(arr);\n///\n/// assert_eq!(merged, vec![1, 2, 3, 4, 5, 6, 7, 8]);\n/// ```\npub fn merge<T>(arr: Vec<T>) -> Vec<T>\nwhere\n    T: Clone + Copy + PartialOrd + std::fmt::Debug,\n{\n    if arr.len() <= 1 {\n        return arr;\n    }\n\n    let pivot = (arr.len() / 2) as f32;\n    let mid = pivot.floor() as usize;\n    let (l, r) = arr.split_at(mid);\n    let left = merge(l.to_vec());\n    let right = merge(r.to_vec());\n\n    return join(left, right);\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::sort;\n\n    #[test]\n    fn e1() {\n        let arr = vec![3, 6, 7, 1, 5, 9, 2, 8, 0, 0, 5, 8];\n        let merged = sort::merge(arr);\n\n        assert_eq!(merged, vec![0, 0, 1, 2, 3, 5, 5, 6, 7, 8, 8, 9]);\n    }\n\n    #[test]\n    fn e2() {\n        let arr = vec![\n            \"executor\",\n            \"law\",\n            \"religion\",\n            \"eyeball\",\n            \"velocity\",\n            \"quartz\",\n            \"convection\",\n            \"wink\",\n            \"distortion\",\n            \"ecclesia\",\n            \"inhibition\",\n            \"secrecy\",\n        ];\n        let merged = sort::merge(arr);\n\n        assert_eq!(\n            merged,\n            vec![\n                \"convection\",\n                \"distortion\",\n                \"ecclesia\",\n                \"executor\",\n                \"eyeball\",\n                \"inhibition\",\n                \"law\",\n                \"quartz\",\n                \"religion\",\n                \"secrecy\",\n                \"velocity\",\n                \"wink\"\n            ]\n        );\n    }\n}\n","traces":[{"line":1,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":5,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":326},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":258},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":90},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":129},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":69},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":60},"fn_name":null}],"covered":20,"coverable":22},{"path":["/","Users","tyler","Desktop","projects","algo","src","sort","mod.rs"],"content":"mod bubble;\nmod merge;\n\npub use bubble::*;\npub use merge::*;\n","traces":[],"covered":0,"coverable":0}]}